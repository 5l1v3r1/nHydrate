//------------------------------------------------------------------------------
// <auto-generated>
//    This code was generated from a template.
//
//    Manual changes to this file may cause unexpected behavior in your application.
//    Manual changes to this file will be overwritten if the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

#region Copyright (c) 2006-2014 nHydrate.org, All Rights Reserved
// -------------------------------------------------------------------------- *
//                           NHYDRATE.ORG                                     *
//              Copyright (c) 2006-2014 All Rights reserved                   *
//                                                                            *
//                                                                            *
// Permission is hereby granted, free of charge, to any person obtaining a    *
// copy of this software and associated documentation files (the "Software"), *
// to deal in the Software without restriction, including without limitation  *
// the rights to use, copy, modify, merge, publish, distribute, sublicense,   *
// and/or sell copies of the Software, and to permit persons to whom the      *
// Software is furnished to do so, subject to the following conditions:       *
//                                                                            *
// The above copyright notice and this permission notice shall be included    *
// in all copies or substantial portions of the Software.                     *
//                                                                            *
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,            *
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES            *
// OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  *
// IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY       *
// CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,       *
// TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE          *
// SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.                     *
// -------------------------------------------------------------------------- *
#endregion
using System;
using System.Linq;
using System.Collections.Generic;
using System.ComponentModel;
using System.Configuration.Install;
using System.Windows.Forms;
using System.Text.RegularExpressions;

namespace PROJECTNAMESPACE
{
	/// <summary>
	/// The database installer class
	/// </summary>
	[RunInstaller(true)]
	public partial class DatabaseInstaller : Installer
	{
		#region Members
		private const string EXENAME_KEY = "-EXENAME";
		private const string DLLNAME_KEY = "-DLLNAME";
		private const string DEFAULT_APPDB_KEY = "-CONNECTIONSTRING";
		private const string DEFAULT_MASTERDB_KEY = "-MASTERDB";

		private string[] PARAMKEYS_UPGRADE = new string[] { "upgrade" };
		private string[] PARAMKEYS_CREATE = new string[] { "create" };
		private string[] PARAMKEYS_MASTERDB = new string[] { "master", "masterdb", DEFAULT_MASTERDB_KEY };
		private string[] PARAMKEYS_APPDB = new string[] { "applicationdb", "connectionstring", DEFAULT_APPDB_KEY };
		private string[] PARAMKEYS_HELP = new string[] { "help", "h", "?" };
		#endregion

		#region Constructor
		/// <summary>
		/// The default constructor
		/// </summary>
		public DatabaseInstaller()
		{
			InitializeComponent();
		}
		#endregion

		#region Install

		/// <summary>
		/// Performs an install of a database
		/// </summary>
		public override void Install(System.Collections.IDictionary stateSaver)
		{
			base.Install(stateSaver);

			var commandParams = GetCommandLineParameters();
			if (PrintHelp(commandParams))
				return;

			var appDbConnectionString = GetAppDbString(commandParams);
			var masterDbConnectionString = GetMasterDbConnectionString(commandParams);
			var isUpgrade = string.IsNullOrEmpty(masterDbConnectionString);
			isUpgrade = GetUpgradeDbSetting(commandParams, isUpgrade);

			if ((isUpgrade && !string.IsNullOrEmpty(appDbConnectionString)) || (!isUpgrade && !string.IsNullOrEmpty(appDbConnectionString) && !string.IsNullOrEmpty(masterDbConnectionString)))
			{
				CommandLineInstall(masterDbConnectionString, appDbConnectionString, isUpgrade, null);
			}
			else
			{
				UIInstall();
			}
		}

		/// <summary>
		/// Performs an install of a database
		/// </summary>
		public void Install(string masterConnection, string databaseName, string connectionString, bool isUpgrade)
		{
			//base.Install(stateSaver);
			Install(masterConnection, databaseName, connectionString, isUpgrade, null);
		}

		/// <summary>
		/// Performs an install of a database
		/// </summary>
		public void Install(string masterConnection, string databaseName, string connectionString, bool isUpgrade, MySql.Data.MySqlClient.MySqlTransaction transaction)
		{
			//base.Install(stateSaver);
			CommandLineInstall(masterConnection, connectionString, isUpgrade, transaction);
		}

		/// <summary>
		/// Installs the internal stored procedures in an existing database
		/// </summary>
		/// <param name="connectionString">The database connection string</param>
		public void InstallInternalProcedures(string connectionString)
		{
			UpgradeInstaller.InstallInternalProcedures(connectionString);
		}

		/// <summary>
		/// Returns the upgrade script for the specified database
		/// </summary>
		/// <param name="connectionString">The database connection string</param>
		public string GetUpgradeScript(string connectionString)
		{
			return UpgradeInstaller.GetUpgradeScript(connectionString);
		}

		#endregion

		#region Uninstall

		/// <summary>
		/// 
		/// </summary>
		/// <param name="savedState"></param>
		public override void Uninstall(System.Collections.IDictionary savedState)
		{
			base.Uninstall(savedState);
		}

		#endregion

		#region NeedsUpdate

		public virtual bool NeedsUpdate(string connectionString)
		{
			return UpgradeInstaller.NeedsUpdate(connectionString);
		}

		#endregion

		#region Helpers

		private string GetDbName(string newDatabaseConnectionString)
		{
			if (!string.IsNullOrEmpty(newDatabaseConnectionString))
			{
				Regex regEx = new Regex(@"(Initial Catalog\s*=|Database\s*=)\s*([\w-]+)[;]?");
				Match firstMatch = regEx.Match(newDatabaseConnectionString);
				if (firstMatch != null && firstMatch.Groups != null && firstMatch.Groups.Count >= 3)
				{
					return firstMatch.Groups[2].Value;
				}
				else
				{
					throw new Exception("Could not find database name in connecton string : " + newDatabaseConnectionString);
				}
			}
			else
			{
				throw new Exception("Empty database connection string : " + newDatabaseConnectionString);
			}
		}

		private bool GetUpgradeDbSetting(Dictionary<string, string> commandParams, bool defaultValue)
		{
			bool retVal = defaultValue;
			foreach (string s in PARAMKEYS_UPGRADE)
			{
				if (commandParams.ContainsKey(s))
				{
					retVal = true;
					break;
				}
			}
			return retVal;
		}

		private string GetMasterDbConnectionString(Dictionary<string, string> commandParams)
		{
			string retVal = string.Empty;
			foreach (string s in PARAMKEYS_MASTERDB)
			{
				if (commandParams.ContainsKey(s))
				{
					retVal = commandParams[s];
					break;
				}
			}
			return retVal;
		}

		private string GetAppDbString(Dictionary<string, string> commandParams)
		{
			string retVal = string.Empty;
			foreach (string s in PARAMKEYS_APPDB)
			{
				if (commandParams.ContainsKey(s))
				{
					retVal = commandParams[s];
					break;
				}
			}
			return retVal;
		}

		private bool PrintHelp(Dictionary<string, string> commandParams)
		{
			bool retVal = false;
			foreach (string s in PARAMKEYS_HELP)
			{
				if (commandParams.ContainsKey(s))
				{
					retVal = true;
					Console.WriteLine("Help Coming Soon!");
					break;
				}
			}
			return retVal;
		}

		private Dictionary<string, string> GetCommandLineParameters()
		{
			var retVal = new Dictionary<string, string>();
			var args = Environment.GetCommandLineArgs();

			var loopcount = 0;
			foreach (var arg in args)
			{
				var regEx = new Regex(@"-(\w+)(:(.*))?");
				var regExMatch = regEx.Match(arg);
				if (regExMatch.Success)
				{
					retVal.Add(regExMatch.Groups[1].Value, regExMatch.Groups[3].Value);
				}
				else
				{
					var tmpKey = Guid.NewGuid().ToString();
					if (loopcount == 0)
						tmpKey = EXENAME_KEY;
					else if (loopcount == 1)
						tmpKey = DLLNAME_KEY;
				}
				loopcount++;
			}

			return retVal;
		}

		/// <summary>
		/// Provides functionality to perform installs from a command line
		/// </summary>
		/// <param name="masterConnectionString">The connection information to the SQL Server master database</param>
		/// <param name="newDatabaseConnectionString">The connection string to the newly created database</param>
		/// <param name="isUpgrade">Determines if this is a database upgrade</param>
		/// <param name="transaction">The transaction to use for this action. If null, one will be created.</param>
		internal void CommandLineInstall(string masterConnectionString, string newDatabaseConnectionString, bool isUpgrade, MySql.Data.MySqlClient.MySqlTransaction transaction)
		{
			if (isUpgrade)
			{
				#region Upgrade
				try
				{
					UpgradeInstaller.UpgradeDatabase(newDatabaseConnectionString, false, transaction);
				}
				catch
				{
					System.Threading.Thread.Sleep(8000);
					try
					{
						UpgradeInstaller.UpgradeDatabase(newDatabaseConnectionString, false, transaction);
					}
					catch
					{
						throw;
					}
				}
				#endregion
			}
			else
			{
				#region Create
				if (this.Action == ActionTypeConstants.Create)
				{
					string newDatabaseName = GetDbName(newDatabaseConnectionString);
					SqlServers.CreateDatabase(masterConnectionString, newDatabaseName);
					var startTime = DateTime.Now;
					while (DateTime.Now.Subtract(startTime).TotalSeconds < 10)
					{
						Application.DoEvents();
					}
				}

				try
				{
					UpgradeInstaller.UpgradeDatabase(newDatabaseConnectionString, true, null);
				}
				catch
				{
					System.Threading.Thread.Sleep(8000);
					try
					{
						UpgradeInstaller.UpgradeDatabase(newDatabaseConnectionString, true, null);
					}
					catch
					{
						throw;
					}
				}
				#endregion
			}
		}

		/// <summary>
		/// 
		/// </summary>
		private void UIInstall()
		{
			if (IdentifyDatabaseConnectionString())
			{
				if (this.Action == ActionTypeConstants.Create)
				{
					UpgradeInstaller.UpgradeDatabase(this.Settings.GetPrimaryConnectionString(), true, null);
				}
				else if (this.Action == ActionTypeConstants.Upgrade)
				{
					UpgradeInstaller.UpgradeDatabase(this.Settings.GetPrimaryConnectionString(), false, null);
				}
				else if (this.Action == ActionTypeConstants.InstallInternal)
				{
					UpgradeInstaller.InstallInternalProcedures(this.Settings.GetPrimaryConnectionString());
				}
			}
		}

		private bool IdentifyDatabaseConnectionString()
		{
			var F = new IdentifyDatabaseForm();
			if (F.ShowDialog() == DialogResult.OK)
			{
				this.Action = F.Action;
				this.Settings = F.Settings;
				return true;
			}
			return false;
		}

		#endregion

		internal InstallSettings Settings { get; private set; }

		/// <summary>
		/// The action to take
		/// </summary>
		public ActionTypeConstants Action { get; private set; }

	}
}